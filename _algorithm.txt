Получаваме число (4 или 8 байта)
    00000000 00000000 00000000 00000000 ( 00000000 00000000 00000000 00000000 )

Взимаме първите 5 бита
                               ___00000
(Записваме ги като число) и го принтираме   ("извеждаме на стандартния изход")

Взимаме следващите пет бита 
                      ______00 000_____
и принтираме

    и т.н. ...

Докато ни останат два или четири бита (в зависимост от размера на полученото число)
    00 ( 00 )
Правим нещо с тях



    Взимаме 5 бита:
    променлива
            маска 11111
    побитово И  & 01101  с полученото число
        записваме 01101  в променливата

    0000 0000 
                         
    Взимаме следващите 5:
    число >> 5
    
    
1. Получаваме число от потребителя. Например: 
        5555
        0001 0101 1011 0011
2. Правим си маска, която да взима пъвите битове (най-младшите от позиция 0 до позиция 4)
    0x1Fu
    0000 0000 0001 1111

3. Използваме побитово И между числото и максата, за да запишем първите 5 бита в нова променлива
    число=      5555    0001 0101 1011 0011 
    оператор    &
    маска=     0x1Fu   0000 0000 0001 1111
    ново число= 19      0000 0000 0001 0011

4. Принтираме резулатата като ново число, съставено само от първите 5 бита на оригиналното число  

5. Преместваме оригиналното число с 5 бита в дясно
    число =     5555    0001 0101 1011 0011
    оператор    >>5
    число =     173     0000 0000 1010 1101

6. Стъпки 3,4 и 5 се повтарят, докато числото не достигне стойност 0
    do {
        unsigned int currentNumber = numberToDecode & mask; 
        printf("%d\n", currentNumber);
    } while ( numberToDecode >>= 5);
